import json
import logging
import sqlite3
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import Application, CommandHandler, CallbackQueryHandler, MessageHandler, filters, ContextTypes
import requests
from bs4 import BeautifulSoup
import hashlib

# –ó–∞–≥—Ä—É–∑–∫–∞ —Ç–æ–∫–µ–Ω–∞ –∏–∑ —Ñ–∞–π–ª–∞ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏
with open('config.json', 'r') as file:
    config = json.load(file)
    TOKEN = config['TOKEN']

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
logging.basicConfig(format='%(asctime)s - %(name)s - %(levelname)s - %(message)s', level=logging.INFO)
logger = logging.getLogger(__name__)

# URL-–∞–¥—Ä–µ—Å –ø–æ–∏—Å–∫–∞ –¥–ª—è –≤—Ç–æ—Ä–æ–≥–æ –∏—Å—Ç–æ—á–Ω–∏–∫–∞
SEARCH_URL_LORDSERIAL = 'https://lordserial.run/index.php?do=search'

# –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ –ø–æ–∏—Å–∫–∞ –∏ –∏–∑–±—Ä–∞–Ω–Ω–æ–≥–æ
search_results_cache = {}


# –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö SQLite
def get_db_connection():
    conn = sqlite3.connect('favorites.db')
    conn.row_factory = sqlite3.Row
    return conn


# –°–æ–∑–¥–∞–Ω–∏–µ —Ç–∞–±–ª–∏—Ü, –µ—Å–ª–∏ –æ–Ω–∏ –Ω–µ —Å—É—â–µ—Å—Ç–≤—É—é—Ç
def create_tables():
    conn = get_db_connection()
    conn.execute('''
        CREATE TABLE IF NOT EXISTS user_favorites (
            chat_id INTEGER,
            title TEXT,
            url TEXT,
            player_url TEXT,
            PRIMARY KEY (chat_id, title)
        )
    ''')
    conn.close()


create_tables()


# –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è HTML-–∫–æ–¥–∞ —Å—Ç—Ä–∞–Ω–∏—Ü—ã
def get_page(url: str, params: dict = None) -> str:
    try:
        response = requests.get(url, params=params)
        response.raise_for_status()  # –ü—Ä–æ–≤–µ—Ä–∫–∞ —É—Å–ø–µ—à–Ω–æ—Å—Ç–∏ –∑–∞–ø—Ä–æ—Å–∞
        return response.text
    except requests.RequestException as e:
        print(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —Å—Ç—Ä–∞–Ω–∏—Ü—ã: {e}")
        return ""


# –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–æ–∏—Å–∫–∞ —Ñ–∏–ª—å–º–æ–≤ –Ω–∞ Goodfilms
def search_goodfilms(query):
    url = 'https://zhqpg.goodfilms.fun/index.php?do=search'
    payload = {
        'do': 'search',
        'subaction': 'search',
        'search_start': '0',
        'full_search': '0',
        'result_from': '1',
        'story': query
    }

    headers = {
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64)',
        'Content-Type': 'application/x-www-form-urlencoded',
    }

    response = requests.post(url, data=payload, headers=headers)

    soup = BeautifulSoup(response.content, 'html.parser')

    results = []
    for item in soup.find_all('div', class_='poster has-overlay grid-item d-flex fd-column'):
        title = item.find('span', class_='poster__title').text.strip()
        link = item.find('a', class_='poster__link')['href']
        genres = item.find('div', class_='poster__subtitle').text.strip()
        ratings = item.find('div', class_='poster__ratings').text.strip()
        image = item.find('img')['src']

        results.append({
            'title': title,
            'link': 'https://zhqpg.goodfilms.fun' + link,
            'genres': genres,
            'ratings': ratings,
            'image': 'https://zhqpg.goodfilms.fun' + image
        })

    return results


# –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –ø–ª–µ–µ—Ä–∞ —Ñ–∏–ª—å–º–∞
def get_movie_player(url):
    response = requests.get(url)
    soup = BeautifulSoup(response.content, 'html.parser')

    video_tag = soup.find('video')
    if video_tag:
        video_src = video_tag['src']
        track = video_tag.find('track')['src'] if video_tag.find('track') else None
        return {'video_src': video_src, 'track': track}
    return None


# –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–∞—Ä—Å–∏–Ω–≥–∞ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ –ø–æ–∏—Å–∫–∞ –Ω–∞ LordSerial
def parse_search_results(content):
    soup = BeautifulSoup(content, 'html.parser')
    results = []
    for item in soup.find_all('div', class_='th-item'):
        title = item.find('div', class_='th-title').get_text(strip=True)
        link = item.find('a', class_='th-in with-mask')['href']
        results.append((f"{title} (–ò—Å—Ç–æ—á–Ω–∏–∫ 1)", link))
    return results


# –§—É–Ω–∫—Ü–∏—è –¥–ª—è –∏–∑–≤–ª–µ—á–µ–Ω–∏—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ —Ñ–∏–ª—å–º–µ
def extract_movie_info(movie_page_content):
    soup = BeautifulSoup(movie_page_content, 'html.parser')
    title = soup.find('h1').get_text(strip=True)
    description = soup.find('div', class_='fdesc').get_text(strip=True)
    return {
        'title': title,
        'description': description,
    }


# –§—É–Ω–∫—Ü–∏—è –¥–ª—è –∏–∑–≤–ª–µ—á–µ–Ω–∏—è —Å—Å—ã–ª–∫–∏ –Ω–∞ –ø–ª–µ–µ—Ä
def extract_player_link(movie_page_content):
    soup = BeautifulSoup(movie_page_content, 'html.parser')
    iframe = soup.find('iframe')
    if iframe:
        return iframe['src']
    player_div = soup.find('div', class_='player-container')
    if player_div:
        player_link = player_div.find('a')
        if player_link and 'href' in player_link.attrs:
            return player_link['href']
    return None


# –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ –ø–æ–∏—Å–∫–∞
def get_search_results(search_term):
    # –ü–æ–ª—É—á–∞–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã –∏–∑ –ø–µ—Ä–≤–æ–≥–æ –∏—Å—Ç–æ—á–Ω–∏–∫–∞
    results_goodfilms = search_goodfilms(search_term)

    # –ü–æ–ª—É—á–∞–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã –∏–∑ –≤—Ç–æ—Ä–æ–≥–æ –∏—Å—Ç–æ—á–Ω–∏–∫–∞
    params_lordserial = {'do': 'search', 'subaction': 'search', 'story': search_term}
    search_content_lordserial = get_page(SEARCH_URL_LORDSERIAL, params=params_lordserial)
    results_lordserial = parse_search_results(search_content_lordserial)

    # –û–±—ä–µ–¥–∏–Ω—è–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã
    combined_results = [(result['title'], result['link']) for result in results_goodfilms] + results_lordserial
    return combined_results


# –§—É–Ω–∫—Ü–∏—è –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –∫–ª–∞–≤–∏–∞—Ç—É—Ä—ã —Å –∫–Ω–æ–ø–∫–∞–º–∏
def build_keyboard(results, current_page, total_pages):
    keyboard = []
    start_index = (current_page - 1) * 5
    end_index = start_index + 5
    paginated_results = results[start_index:end_index]

    for idx, (title, _) in enumerate(paginated_results):
        keyboard.append([InlineKeyboardButton(title, callback_data=f"movie_{start_index + idx}")])

    if current_page > 1:
        keyboard.append([InlineKeyboardButton("‚¨ÖÔ∏è –ü—Ä–µ–¥—ã–¥—É—â–∞—è", callback_data=f'prev_{current_page - 1}')])
    if current_page < total_pages:
        keyboard.append([InlineKeyboardButton("–°–ª–µ–¥—É—é—â–∞—è ‚û°Ô∏è", callback_data=f'next_{current_page + 1}')])

    return InlineKeyboardMarkup(keyboard)


# –§—É–Ω–∫—Ü–∏—è –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –∫–ª–∞–≤–∏–∞—Ç—É—Ä—ã —Å –∫–Ω–æ–ø–∫–∞–º–∏ –Ω–∞ —Å—Ç—Ä–∞–Ω–∏—Ü–µ –∏–∑–±—Ä–∞–Ω–Ω–æ–≥–æ
def build_favorites_keyboard():
    keyboard = [
        [InlineKeyboardButton("üè† –ì–ª–∞–≤–Ω–∞—è", callback_data='home')]
    ]
    return InlineKeyboardMarkup(keyboard)


def get_unique_id(url):
    return hashlib.md5(url.encode()).hexdigest()[:10]


# –§—É–Ω–∫—Ü–∏—è –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –∫–ª–∞–≤–∏–∞—Ç—É—Ä—ã –Ω–∞ —Å—Ç—Ä–∞–Ω–∏—Ü–µ —Ñ–∏–ª—å–º–∞
def build_movie_keyboard(movie_url, player_url, is_favorite=False):
    unique_id = get_unique_id(movie_url)
    keyboard = []

    if player_url:
        keyboard.append([InlineKeyboardButton("‚ñ∂Ô∏è –°–ú–û–¢–†–ï–¢–¨", url=player_url)])
    else:
        keyboard.append([InlineKeyboardButton("‚ùì –ù–µ –Ω–∞–π–¥–µ–Ω –ø–ª–µ–µ—Ä", callback_data='none')])

    if is_favorite:
        keyboard.append([InlineKeyboardButton("‚úÖ –£–∂–µ –≤ –∏–∑–±—Ä–∞–Ω–Ω–æ–º", callback_data='none')])
    else:
        keyboard.append([InlineKeyboardButton("‚≠ê –î–æ–±–∞–≤–∏—Ç—å –≤ –∏–∑–±—Ä–∞–Ω–Ω–æ–µ", callback_data=f"favorite_{unique_id}")])

    keyboard.append([InlineKeyboardButton("üè† –ì–ª–∞–≤–Ω–∞—è", callback_data='home')])

    return InlineKeyboardMarkup(keyboard)


# –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –∏–∑–±—Ä–∞–Ω–Ω–æ–≥–æ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è:
def get_user_favorites(chat_id):
    conn = get_db_connection()
    cursor = conn.execute('SELECT title, player_url FROM user_favorites WHERE chat_id = ?', (chat_id,))
    favorites = cursor.fetchall()
    conn.close()
    return {'favorites': [row['title'] for row in favorites],
            'links': {row['title']: row['player_url'] for row in favorites}}  # –ò—Å–ø–æ–ª—å–∑—É–µ–º player_url


# –§—É–Ω–∫—Ü–∏—è –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –∫–æ–º–∞–Ω–¥—ã /start
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    logger.info('–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–∞–∂–∞–ª /start')
    keyboard = [
        [InlineKeyboardButton("üîç –ü–æ–∏—Å–∫", callback_data='search')],
        [InlineKeyboardButton("‚≠ê –ò–∑–±—Ä–∞–Ω–Ω–æ–µ", callback_data='favorites')]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    welcome_message = (
        "üé¨ –î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ –±–æ—Ç–∞ –¥–ª—è –ø–æ–∏—Å–∫–∞ —Ñ–∏–ª—å–º–æ–≤ –∏ —Å–µ—Ä–∏–∞–ª–æ–≤ –æ—Ç –∫–∞–Ω–∞–ª–∞ <b>48/91</b> (https://t.me/tommorow4891)! üé¨\n\n"
        "–ù–∞–∂–º–∏—Ç–µ '–ü–æ–∏—Å–∫' –¥–ª—è –Ω–∞—á–∞–ª–∞."
    )

    # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —Å–æ–¥–µ—Ä–∂–∏—Ç –ª–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
    if update.message:
        chat_id = update.message.chat_id
    else:
        chat_id = update.callback_query.message.chat_id

    await context.bot.send_message(
        chat_id=chat_id,
        text=welcome_message,
        reply_markup=reply_markup,
        parse_mode='HTML'
    )


# –§—É–Ω–∫—Ü–∏—è –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –Ω–∞–∂–∞—Ç–∏—è –∫–Ω–æ–ø–∫–∏
async def button(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    data = query.data
    chat_id = query.message.chat_id

    if data == 'search':
        await query.edit_message_text(
            text="üîç –í–≤–µ–¥–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ —Ñ–∏–ª—å–º–∞ –∏–ª–∏ —Å–µ—Ä–∏–∞–ª–∞, –∫–æ—Ç–æ—Ä—ã–π –≤—ã —Ö–æ—Ç–∏—Ç–µ –Ω–∞–π—Ç–∏:"
        )
        return

    if data == 'favorites':
        favorites = get_user_favorites(chat_id)
        if not favorites['favorites']:
            await query.edit_message_text(
                text="‚ö†Ô∏è –í –∏–∑–±—Ä–∞–Ω–Ω–æ–º –ø–æ–∫–∞ –Ω–∏—á–µ–≥–æ –Ω–µ—Ç. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –ø–æ–∏—Å–∫ –¥–ª—è –¥–æ–±–∞–≤–ª–µ–Ω–∏—è —Ñ–∏–ª—å–º–æ–≤."
            )
        else:
            favorite_titles = '\n'.join(favorites['favorites'])
            await query.edit_message_text(
                text=f"üìö –í–∞—à–µ –∏–∑–±—Ä–∞–Ω–Ω–æ–µ:\n{favorite_titles}",
                reply_markup=build_favorites_keyboard()
            )
        return

    if data.startswith('movie_'):
        index = int(data.split('_')[1])
        results = search_results_cache.get('results', [])
        if 0 <= index < len(results):
            title, movie_url = results[index]
            if 'goodfilms' in movie_url:
                movie_page_content = get_page(movie_url)
                movie_info = extract_movie_info(movie_page_content)
                player_url = get_movie_player(movie_url).get('video_src')  # –ò—Å–ø–æ–ª—å–∑—É–µ–º –Ω–æ–≤—ã–π –º–µ—Ç–æ–¥

            else:
                movie_page_content = get_page(movie_url)
                movie_info = extract_movie_info(movie_page_content)
                player_url = extract_player_link(movie_page_content)

            conn = get_db_connection()
            cursor = conn.execute('SELECT 1 FROM user_favorites WHERE chat_id = ? AND url = ?', (chat_id, movie_url))
            is_favorite = cursor.fetchone() is not None
            conn.close()

            response_message = (
                f"<b>–ù–∞–∑–≤–∞–Ω–∏–µ:</b> {movie_info['title']}\n"
                "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n"
                f"<b>–û–ø–∏—Å–∞–Ω–∏–µ:</b>\n<i>{movie_info['description']}</i>\n"
                "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n"
            )

            await query.edit_message_text(
                text=response_message,
                parse_mode='HTML',
                reply_markup=build_movie_keyboard(movie_url, player_url, is_favorite)
            )
        return

    if data.startswith('favorite_'):
        unique_id = data.split('_')[1]
        movie_url = next((url for url, uid in search_results_cache['results'] if get_unique_id(url) == unique_id), None)

        if movie_url:
            conn = get_db_connection()
            conn.execute('INSERT OR IGNORE INTO user_favorites (chat_id, title, url, player_url) VALUES (?, ?, ?, ?)',
                         (chat_id, movie_url, movie_url, ''))
            conn.commit()
            conn.close()

            await query.edit_message_text(
                text="‚úÖ –§–∏–ª—å–º –¥–æ–±–∞–≤–ª–µ–Ω –≤ –∏–∑–±—Ä–∞–Ω–Ω–æ–µ!",
                reply_markup=build_favorites_keyboard()
            )
        return

    if data.startswith('prev_') or data.startswith('next_'):
        current_page = int(data.split('_')[1])
        search_term = search_results_cache.get('search_term', '')
        results = get_search_results(search_term)
        search_results_cache['results'] = results
        total_pages = (len(results) + 4) // 5
        reply_markup = build_keyboard(results, current_page, total_pages)
        await query.edit_message_text(
            text=f"üîç –†–µ–∑—É–ª—å—Ç–∞—Ç—ã –ø–æ–∏—Å–∫–∞ –ø–æ –∑–∞–ø—Ä–æ—Å—É '{search_term}':",
            reply_markup=reply_markup
        )
        return

    if data == 'home':
        await start(update, context)
        return


# –§—É–Ω–∫—Ü–∏—è –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Ç–µ–∫—Å—Ç–æ–≤—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π (–ø–æ–∏—Å–∫)
async def text_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    search_term = update.message.text
    if search_term:
        search_results = get_search_results(search_term)
        search_results_cache['results'] = search_results
        search_results_cache['search_term'] = search_term
        total_pages = (len(search_results) + 4) // 5
        reply_markup = build_keyboard(search_results, 1, total_pages)
        await update.message.reply_text(
            text=f"üîç –†–µ–∑—É–ª—å—Ç–∞—Ç—ã –ø–æ–∏—Å–∫–∞ –ø–æ –∑–∞–ø—Ä–æ—Å—É '{search_term}':",
            reply_markup=reply_markup
        )


# –ó–∞–ø—É—Å–∫ –±–æ—Ç–∞
if __name__ == '__main__':
    application = Application.builder().token(TOKEN).build()

    application.add_handler(CommandHandler("start", start))
    application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, text_handler))
    application.add_handler(CallbackQueryHandler(button))

    application.run_polling()
